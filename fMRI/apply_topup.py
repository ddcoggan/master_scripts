#!/usr/bin/env pythonimport osimport pydicomimport numpy as npdef apply_topup(filename1, filename2,angle1,angle2,out_file=None,nvol=1,dicom_name="default",filename3=None,out_file3=None,verbose=False):        '''    "filename1", type=str,help="input NIFTI filename for the first EPI image")    "filename2", type=str,help="input NIFTI filename for the second EPI image, which should have a different phase encoding direction relative to filename1"    "angle1", type=float,help="angle in degrees of the PE direction relative to horizontal for filename1",default=0    "angle2", type=float,help="angle in degrees of the PE direction relative to horizontal for filename2",default=180    "nvol", type=int,help="volume number to use for topup (assuming 4D nifti file)",default=1,dest="nvol"    "dicom_name", type=str,help="the name of the dicom file to be used for calculation of the EPI band width and total acquisition time, passed into TOPUP for accurate scaling of the calculated B0 map.",default="default",dest="dicom_name"    "filename3", type=str,help="filename of an extra NIFTI image to which you want to apply the TOPUP correction calculated from the images above. It is assumed that this image has the same phase encoding as filename1.",default="NONE",dest="filename3"    "out_file3", type=str,help="output file path for corrected filename3"    "verbose", help="display more header information", action="store_true")    '''    tempDir = f'{os.path.dirname(filename1)}/temp'    os.makedirs(tempDir, exist_ok=True)    # read the EPI bandwidth from the dicom file if available    if (dicom_name != 'default'):            # set constants        wfs_ppm=3.5  #the water - fat shift in units of ppm (i.e. field strength independent)        larmor_freq = 42.58 #MHz/T            # read the DICOM header to find the water fat shift of the sequence        ds=pydicom.dcmread(dicom_name)            # extract particular fields for calculations        wfs_seq=float(ds['2001','1022'].value)  #in pixels        try:            field_strength=float(ds['0018','0087'].value)  #in Tesla        except:            field_strength=float(ds['2001','1085'].value)  #in Tesla            EPI_factor=float(ds['2001','1013'].value)   #scalar        nsl=float(ds['2001','1018'].value)  #scalar            try:            TR=float(ds.RepetitionTime) #in ms        except:            TR=ds['2005','1030'].value            TR=TR[0]            bw= larmor_freq * field_strength * wfs_ppm / wfs_seq    #Hz/T * T * null / pixel        trt=1000*wfs_seq / (larmor_freq * field_strength * wfs_ppm  * (EPI_factor+1)) * EPI_factor #in ms            if verbose:            print("\nfilename: " + dicom_name)            print("water fat shift = " + str(wfs_seq) + " pixels")            print("field strength = " + str(field_strength) + "T")            print("epi factor = " + str(EPI_factor))            print("calculated bandwidth = " + str(bw) + " Hz")            print("total read out time (per echo train) = " + str(trt) + " ms")            print("(trt) * (#of sl) = " + str(trt*nsl) + " ms")            print("TR = " + str(TR) + " ms\n")        else:            trt=1000    #default total read out time is 1000 ms, which is arbitrary, but is what the fsl guide uses when you want a default (meaningless) value            imtypenum=nvol #this sets the volume number in the nifti file that will be analyzed        if verbose:            print("============================================================")        print(filename1 + " acquired at " + str(angle1) + " degrees")        print(filename2 + " acquired at " + str(angle2) + " degrees")        print("volume number to be used for TOPUP: " + str(imtypenum))        print("============================================================\n")            x1=np.cos(angle1/180*np.pi) #convert angle 1 to its x and y components on the unit circie    y1=np.sin(angle1/180*np.pi) #convert angle 1 to its x and y components on the unit circie    x2=np.cos(angle2/180*np.pi) #convert angle 1 to its x and y components on the unit circie    y2=np.sin(angle2/180*np.pi) #convert angle 1 to its x and y components on the unit circie        print(str(x1) + " " + str(y1) + " 0 " + str(trt/1000))    print(str(x2) + " " + str(y2) + " 0 " + str(trt/1000))        #parse out the dir of filename1    filename1base = os.path.basename(filename1).split(".")[0]    filename1dir = os.path.dirname(filename1)    newfilename = f"{tempDir}/{filename1base}_topup"    out1 = os.popen(f"fslnvols {filename1}").read()   #check the number of volumes in the images passed    nvols_fn1=int(out1[0:-1])    #note the minus one because we need strip off the new line character    out2 = os.popen(f"fslnvols {filename2}").read()   #check the number of volumes in the images passed    nvols_fn2=int(out2[0:-1])    #note the minus one because we need strip off the new line character        if verbose:        print("\n================================================================")        print("running fslmerge with the following parameters:\n")        print(" topup calculated data base name: " + newfilename)        print(" input filename 1: " + filename1 + "---> " + str(nvols_fn1) + " volumes")        print(" input filename 2: " + filename2 + "---> " + str(nvols_fn2) + " volumes")        print("================================================================\n")        # verify that the number of slices is an even number (apparently required by topup)    new_filenames = [filename1, filename2]    for filename in [filename1, filename2]:        size_string = os.popen(f"fslsize {filename}").read()        dim1_index = size_string.find("dim1")        dim2_index = size_string.find("dim2")        dim3_index = size_string.find("dim3")        dim4_index = size_string.find("dim4")        dim1_sizestr = size_string[dim1_index+4:dim2_index]        dim2_sizestr = size_string[dim2_index+4:dim3_index]        dim3_sizestr = size_string[dim3_index+4:dim4_index]        nrow = int(dim1_sizestr)        ncol = int(dim2_sizestr)        nsl = int(dim3_sizestr)        isodd = nsl % 2        if verbose:            print("\n" + filename + " properties:")            print("# of rows: " + str(nrow))            print("# of cols: " + str(ncol))            print("# of sl = " + str(nsl) + "\n")        if isodd == 1:            print("WARNING: topup prefers an even number of slices (apparently.. don't ask me). Subtracting a slice to accomodate this.")            nsl_mod=nsl-3            new_filenames[f] = f"{tempDir}/{os.path.basename(filename).split('.')[0]}_topup_nsl{nsl_mod}"            os.system(f"fslroi {filename} {new_filenames[f]} 0 -1 0 -1 0 {nsl_mod} 0 -1")   #string to be used to add one blank slice to the image.    filename1 = new_filenames[0]    filename2 = new_filenames[1]        #separate out the specified image volume from both input files    filename1_b0 = f"{tempDir}/{os.path.basename(filename1).split('.')[0]}_topup_b0"    filename2_b0 = f"{tempDir}/{os.path.basename(filename2).split('.')[0]}_topup_b0"    os.system(f"fslroi {filename1} {filename1_b0} {imtypenum-1} 1")    os.system(f"fslroi {filename2} {filename2_b0} {imtypenum-1} 1")        #merge the two dti filesets into one    merged_filename = newfilename+"mergedb0"    print("creating merged file with different PE images: "+merged_filename)    os.system(f"fslmerge -t {merged_filename} {filename1_b0} {filename2_b0}")   #build the list of strings that need to be passed to fslmerge            #create the text file by looping over all the volumes in each of the two DTI studies    out1 = os.popen(f"fslnvols {filename1_b0}").read()  #this needs to change to the merged file name    nvols1=int(out1[0:-1])    #note the minus one because we need strip off the new line character    out2 = os.popen(f"fslnvols {filename2_b0}").read()   #this needs to change to the merged file name    nvols2=int(out2[0:-1])    #note the minus one because we need strip off the new line character    txtfilename = newfilename+"_acqparams.txt"        if verbose:        print("number of b0 vols from filename1_b0 = ",nvols1)        print("number of b0 vols from filename2_b0 = ",nvols2)        print("topup text file name: "+txtfilename)        topup_params_1 = str(x1) + " " + str(y1) + " 0 " + str(trt/1000) + "\n"    topup_params_2 = str(x2) + " " + str(y2) + " 0 " + str(trt/1000) + "\n"        F=open(txtfilename,"w");    F.write(topup_params_1)    F.write(topup_params_2)    F.close()        if verbose:        print("topup parameters:\n" + topup_params_1 + topup_params_2)        # run topup    print("calculating topup...")    os.system(f"topup --imain={merged_filename} --datain={txtfilename} --config=b02b0.cnf --out={newfilename} --fout={newfilename}_fieldmap")   #build the list of strings that need to be passed to topup        # apply topup    print("applying topup...")    os.system(f"applytopup --imain={filename1} --datain={txtfilename} --inindex=1 --topup={newfilename} --out={out_file} --method=jac")    #build the list of strings that need to be passed to topup        # apply topup again if there is another image passed for correction    if filename3:        os.system(f"applytopup --imain={filename3} --datain={txtfilename} --inindex=1 --topup={newfilename} --out={out_file3} --method=jac")    #build the list of strings that need to be passed to topup    os.system(f'rm -rf {tempDir}')if __name__ == "__main__":    runTopUp('/mnt/HDD2_16TB/projects/p022_occlusion/fMRI/v5/data/individual/F016/220315/functional/occlusion_v5_attnOff/run01/inputsTest/rawData.nii',             '/mnt/HDD2_16TB/projects/p022_occlusion/fMRI/v5/data/individual/F016/220315/functional/occlusion_v5_attnOff/run01/inputsTest/oppPE.nii',             90, 270)